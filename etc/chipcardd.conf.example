# $RCSfile$
#                             -------------------
#    cvs         : $Id$
#    begin       : Mon Mar 01 2004
#    copyright   : (C) 2004 by Martin Preuss
#    email       : martin@libchipcard.de
#
# ***************************************************************************
# *          Please see toplevel file COPYING for license details           *
# ***************************************************************************/
#
#
# This file is used by the chipcard daemon.
# Please modify it to your needs and copy it to
#           $PREFIX/etc/chipcard/server/chipcardd.conf
#

# if this is "0" then the server won't start
#
enabled="1"

#
# role is the role this daemon is playing. 
# possible values are standAlone, master and slave
# if role is set to "slave" then this file must have a SlaveManager section
# with a master subsection which contains the address and port of the
# master.
#
role="standAlone"


# ===========================================================================
# Server Sockets
#
# These sections describe server points. You may use multiple of those
# sections (in that case the daemon will listen on multiple sockets).
# Please choose one of the sections below by removing the ".inactive" suffix.


# ---------------------------------------------------------------------------
# local server, using Unix Domain Sockets which can only be
# connected from the very same machine. This is the preferred mode on 
# *nix systems (like Linux, *BSD etc, but not on Windows which does not
# support Unix Domain sockets).
#
server {
  typ="local"                 
  addr="/var/run/chipcard.comm"
  
  #
  # The default is ti use the first server section as the address to expect
  # drivers to connect to. If there are multiple addresses the server is to
  # bind to than the following selects the server to use for drivers.
  #
  int useForDrivers="1"
  
  #
  # The same as above, except for services.
  #
  int useForServices="1"
} # server


# ---------------------------------------------------------------------------
# private server using SSL secured sockets.
# New certificates are stored in the folder given by "newcertdir",
# received certificates are checked against those in "certdir"
# This is the recommended mode on systems which can't use "local" (e.g.
# Windows).
#
server.inactive {
  typ="private"
  addr="127.0.0.1"
  port="55555"

  cafile="/etc/chipcard/server/ca.pem"
  certfile="/etc/chipcard/server/cert.pem"
  keyfile="/etc/chipcard/server/cert.pem"
  dhfile="/etc/chipcard/server/dh1024.pem"
} # server


# ---------------------------------------------------------------------------
# secure server using SSL secured sockets. In addition to mode
# "private" the certificates of the clients are checked against
# those stored in the "certdir". If the client certificate could
# not be found or is invalid the connection is aborted.
#
server.inactive {
  typ="secure"
  addr="127.0.0.1"
  port="55555"
  certdir="/etc/chipcard/server/certs"
  newcertdir="/var/lib/chipcard/server/newcerts"
  certfile="/etc/chipcard/server/chipcardd.crt"
  dhfile="/etc/chipcard/server/dh1024.pem"
} # server


#
# this section describes some basic configuration variables.
# For any missing variable a reasonable default value is used
#



# ===========================================================================
# Paths
#
# Starting with version 1.9.16 Libchipcard no longer depends on hardcoded
# paths. Instead on Windows the Registry is consulted and this group.
# This group here takes precedence, so if present all paths are taken from 
# here.
#

Paths {

#  char ServiceExecDir=""
#  char DataDir=""
#  char NewCertDir=""
#  char TrustedCertDir=""
#  char LogDir=""

} # Paths




# ===========================================================================
# Device Manager
#
# This group contains all data for the Device Manager. The Device Manager
# handles the allocation and management of the reader devices.
#

DeviceManager {

  # -------------------------------------------------------------------------
  # Autoconfiguration
  #
  
  #
  # if "1" then autoconfiguration (via USB scanning) is disabled
  # For autoconfiguration to work libchipcard-server must be linked against
  # libUSB. This is automatically done if libusb is available at compile time.
  #
  int disableAutoConf="0"
  
  #
  # if "1" then scanning for PCI devices is disabled.
  #
  int disablePciScan="0"
  
  #
  # if "1" then scanning for raw USB devices is disabled.
  #
  int disableUsbRawScan="0"
  
  #
  # if "1" then scanning for raw USB serial devices (/dev/ttyUSBx) is disabled.
  #
  int disableUsbTtyScan="0"
  
  
  #
  # minimum time in seconds which has to elapse between two hardware scans
  # A value of "0" makes the chipcard daemon only scan once (thus allowing
  # only initial setup of already connected readers) or after a SIGUSR2 has
  # been received (thus allowing hardware scans triggered by udev)
  #
  int hardwareScanInterval="2"

  #
  # If a hardware scan has been triggered by a SIGNAL then do a hardware scan
  # every 2 seconds for this number of intervals.
  # This value should be at least 2 to make sure all hardware changes are
  # caught.
  # Libchipcard uses the signal SIGUSR2 to trigger a hardware scan (e.g.
  # "killall -SIGUSR2 chipcardd" would make the server rescan the hardware).
  #
  int hardwareScanTriggerIntervals="4"

  #
  # driver blacklisting (drivers in this list are ignored)
  #
  #char driverBlackList="ccid_ifd"


  # -------------------------------------------------------------------------
  # Timout Values
  #

  #
  # time to wait until the driver is actually started
  #
  int driverStartDelay="0"
  
  #
  # timeout when starting a driver (in seconds)
  #
  int driverStartTimeout="10"

  #
  # timeout when restarting a driver after an error (in seconds)
  #
  int driverRestartTime="10"
  
  #
  # timeout when starting a reader (including driverStartTimeout, in seconds)
  #
  int readerStartTimeout="20"
  
  #
  # time after which a driver is shut down when idle (in seconds)
  #
  int driverIdleTimeout="10"

  #
  # time to wait until the reader is actually started
  #
  int readerStartDelay="1"
  
  #
  # time after which a reader is shut down when idle (in seconds)
  #
  int readerIdleTimeout="10"
  
  #
  # maximum execution time for a command (in seconds)
  #
  readerCommandTimeout="60"

  #
  # timeout when restarting a reader after an error (in seconds)
  #
  int readerRestartTime="10"


  # -------------------------------------------------------------------------
  # Drivers
  #
  # A driver section contains information about a driver and the readers
  # supported by this driver.
  #
  # Please note that you only need driver sections for serial readers (i.e.
  # readers which are connected to COM1-COMx). USB readers are autodetected.
  #
  # If you have an USB reader which is not recognized by Libchipcard you 
  # really should drop an email to martin@libchipcard.de containing the output
  # of the command "lsusb" and the following extra information:
  # - path and name of the driver
  # - location from where you downloaded the driver
  # - name of the card reader
  # That would allow me to add the driver to the list and hence to support
  # this card reader.
  #
  # However, if autoconfiguration is disabled (either by config file, see 
  # above or because libUSB is not available) you need a driver section and 
  # reader sections therein for every reader you want to use.
  #
  # To activate one of the examples below remove the ".inactive" suffix
  # (driver.inactive -> driver)
  
  
  # -------------------------------------------------------------------------
  # driver section for a Kobil Kaan Professional (serial)
  #
  # remove the ".inactive" of this group's name to enable the driver
  # you will most probably have to change the "port" value in the reader
  # section below
  #

  driver.inactive {
    # the general type of the driver
    # Currently available are these:
    # - ctapi (for CTAPI type drivers)
    # - ifd (for lowlevel drivers written for PC/SC)
    # - ifdold (for lowlevel drivers written for old PC/SC)
    #
    char driverType="ctapi"
    
    # This name should not be modified, since this is the name used to lookup
    # the format of card commands in the cards XML files
    #
    char driverName="kobil_ctapi"
    
    # currently not used by the written drivers, but this is sent to the 
    # driver as a command line argument. New drivers might use this one.
    #
    char driverDataDir="/var/lib/chipcard/drivers/ctapi"
    
    # path and name of the low-level driver file. This is the driver actually
    # provided by the manufacturer of the card reader
    #
    char libraryFile="/usr/lib/kobil/libct.so"
    

    # -----------------------------------------------------------------------
    # This is a sub-section under a driver section.
    # One driver can generally run multiple readers (as long as the same
    # libraryFile is used, i.e. all readers are of the same type).
    # However, you should only use one reader per driver, only then they are
    # all handled independantly (each driver runs in its own process)
    #

    reader {
      #
      # you should not alter this name, it is used to lookup the commands
      # special to this reader in the cards XML files
      #
      char readerType="kobilpro"
      
      #
      # reader name (send to the application and used for logging)
      #
      char readerName="Kobil1"
      
      #
      # normally each reader has one card slot. However, there are some
      # readers which have two (or might have even more). With chipcard the 
      # number of slots is not limited anymore.
      #
      int slots="1"
  
      #
      # needed for serial readers
      #
      char busType="serial"
      
      #
      # the meaning of the port value is completely defined by the driver:
      # - for CTAPI drivers this is the value given as CTN argument to CT_init
      # - for IFD drivers this value is given as CHANNEL in IFDHCreateChannel
      # In the case of a Kobil Kaan the value "1" stands for COM1.
      #
      int port="1"
      
      #
      # describes the capabilities of the reader (comma separated list),
      # currently available are:
      # - keypad (->reader has a built-in key pad)
      # - display (->reader has a built-in display)
      # Only add flags which are supported by your reader.
      #
      char flags="keypad","display"
    }
  }
  
  
  # ---------------------------------------------------------------------------
  # driver section for a Towitoko Chipdrive Micro (serial)
  #

  driver {
    char driverType="ctapi"
    char driverName="tow_ctapi"
    char driverDataDir="/var/lib/chipcard/drivers/ctapi"
    char libraryFile="/usr/lib/chipcard-server/lowlevel/libtowitoko.so"
  
    vars {
      #char WriteBoundary="32" # for Towitoko 2.0.7
      char WriteBoundary="249" # for Towitoko 2.0.8 (not yet released)
    }
    
    reader {
      char readerType="tow_cdm"
      char readerName="tow1"
      int slots="1"
      char busType="serial"
      int port="0" # 0=COM1, 1=COM2 etc
    }
  } # driver

  # ---------------------------------------------------------------------------
  # driver section for a Cherry Keyboard Reader 1501
  #

  driver.inactive {
    char driverType="ctapi"
    char driverName="cherry_ctapi"
    char driverDataDir="/var/lib/chipcard/drivers/ctapi"
    char libraryFile="/usr/lib/libctapi_cherry.so"
  
    reader {
      char readerType="cherry_keyboard"
      char readerName="cherry_1501"
      int port="3"                        # value here doesn't matter
      int slots="1"
      char busType="serial"
    }
  } # driver

} # DeviceManager




# ===========================================================================
# Card Manager
#
# This group contains all data for the Card Manager. The Card Manager
# handles the allocation and management of the chip cards which are inserted
# in readers.
#

CardManager {
  #
  # After this amount of seconds the reader a card is inserted in is allowed
  # to shut down.
  #
  int unusedTimeout="10"
  
  #
  # Keep a card at least this amount of seconds after it has been advertised
  # to a client.
  #
  int minimumKeepTime="20"
}



# ===========================================================================
# Service Manager
#
# This group contains all data for the Service Manager. The Service Manager
# handles the allocation and management of chipcard services.
#

ServiceManager {
  # -------------------------------------------------------------------------
  # Services
  #
  # A service basically is a chipcard client which is automatically started
  # by the chipcard server. It can be started on a users' demand (if a user
  # wants to use a service) or upon start of the server (if the flag 
  # "autoload" is given in the service section).


  #
  # time to wait until the service is actually started
  #
  int serviceStartDelay="0"
  
  #
  # timeout when starting a service (in seconds)
  #
  int serviceStartTimeout="30"

  #
  # timeout when restarting a service after an error (in seconds)
  #
  int serviceRestartTimeout="60"
  
  #
  # time after which a service is shut down when idle (in seconds)
  #
  int serviceIdleTimeout="10"

  
  # ---------------------------------------------------------------------------
  # Service section for German Medical Card Service
  #
  # This service is used by GnuMed to sample inserted German medical cards.
  # It is started when the chipcard server is started (due to the "autoload"
  # flag given below)
  
  service.inactive {
    char serviceType="kvks"
    char dataDir="/tmp"
    char flags="autoload" # this makes the server load this service upon
                          # its own start
  } # service
  
}


SlaveManager {
  master.inactive {
    typ="private"
    addr="127.0.0.1"
    port="55555"
  
    certfile="/usr/etc/chipcard/client/client_cert.pem"
    keyfile="/usr/etc/chipcard/client/client_key.pem"
    cafile="/usr/etc/chipcard/client/ca_cert.pem"
  }
}




